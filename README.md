# FabrikamFiber

This project was originally started by Richard Hundhausen and distributed on [CodePlex](https://fabrikam.codeplex.com/) as an application for training users in Visual Studio and development practices.

I have forked this project from Patrick Lang, who should be given credit for containerizing the project.

## Step by Step - Getting Started

We will walk through how to take the fabrikam solution, shift & run the containers locally, and then orchestrate them in Azure through Kubernetes and Service Fabric.

## Get the Project

Grab the project and checkout the local branch:

```PowerShell
git clone https://github.com/cwilhit/fabrikamfiber.git
git checkout local
```

You can run this application locally right away, if you have a local instance of SQL installed.

## Add Local Container Support

Let's add container support! Right click on the project 'FabrikamFiber.Web' and click Add -> Container Orchestrator Support. In the dialog box, select "Docker Compose". Click OK.

This will generate a new project in your solution called "docker-compose". It will also check to see if you have the necessary containers already installed on your system. If they are missing, it will pull them (this can take awhile). Now we need to modify the content generated by adding docker support.

Open "docker-compose.yml" in the docker-compose project. Replace the content with this:

```yaml
version: '3'

services:
  fabrikamfiber.web:
    image: fabrikamfiber.web
    build:
      context: .\FabrikamFiber.Web
      dockerfile: Dockerfile
```

Likewise, if you click the arrow next to the docker-compose.yml file, it will reveal a nested file called "docker-compose.override.yml". Open this file and replace the content with:

```yaml
version: '3'

services:
  fabrikamfiber.web:
    ports:
      - "80"
    depends_on:
      - db
    environment:
      DB_SA_PASSWORD: "Password1"
      DB_SERVICE_HOST: "db"
      DB_SERVICE_PORT: 1433
  db:
    image: microsoft/mssql-server-windows-developer:1709
    environment:
      SA_PASSWORD: "Password1"
      ACCEPT_EULA: "Y"
    ports:
      - "1433"
    healthcheck:
      test: [ "CMD", "sqlcmd", "-U", "sa", "-P", "Password1", "-Q", "select 1" ]
      interval: 1s
      retries: 20
networks:
  default:
    external:
      name: nat
```

Docker Compose is an orchestrator. It consumes these .yaml files, which describe the relationship of our containers to the orchestrator, as well as many other things--like setting environment variables in the container to configure our SQL database instance. 

Lastly, we need to update our project to use our containerized SQL database. To do this, we must update FabrikamFiberWebContext.cs, found in the FabrikamFiber.DAL project. Change line 16 from:

```Csharp
public FabrikamFiberWebContext()
            : base("DefaultConnection")
        {
        }
```

to

```Csharp
public FabrikamFiberWebContext()
            : base("FabrikamFiber-Express")
        {
        }
```

## Run the Project Locally

With these changes made, make sure to set the docker-compose project as your start-up project. Build & Run your solution. Instead of launching your application locally, it will use docker compose to bring up your solution in containers. A new browser tab will launch automatically when the application starts 

You may also jump straight to this point in the lab by executing:

```PowerShell
#The master branch already contains the docker-compose project, configured and ready to go.
git clean -f
git checkout master
git pull
```

# Shifting into Azure

Up to this point, we have seen our traditional .NET web app shifted into containers & locally orchestrated and run. Now, we will deploy the same containers into Azure. There are two popular ways to orchestrate containers in Azure:

* Service Fabric
* Kubernetes  

We will walk through the process for setting up both a Service Fabric and Kubernetes cluster in Azure, respectively. Before we do this, we need to set up a registry to keep our image in Azure. Let's check out how to do that.

## Set up an Azure Container Registry

In a PowerShell window, run the following:

```PowerShell
$acrName = "fabfiberregistry" #set this to what you want
$subscriptionId = "fb900a94-2376-4f81-9e34-f66d1604f9c0" #set this appropriately
$rgName = "cwilhit-fiber" #set this appropriately

Login-AzureRmAccount -SubscriptionId $subscriptionId
New-AzureRmResourceGroup -Name $rgName -Location "westus2"
$registry = New-AzureRMContainerRegistry -ResourceGroupName $rgName -Name $acrName -EnableAdminUser -Sku Basic
```

Once we've created our registry, we'll need to push the container image to it. **But first we need to do a 'Release' build of our project in Visual Studio**. This ensure that our container image is built. In Visual Studio, toggle the build option to 'Release' and compile the solution.

After you have completed the build, do the following in a PowerShell window:

```PowerShell
#login to the container registry you created 
$creds = Get-AzureRmContainerRegistryCredential -RegistryName $acrName -ResourceGroupName $rgName
$creds.Password | docker login $registry.LoginServer -u $creds.Username --password-stdin
$loginServer = $registry.LoginServer

#Tag the fabrikam fiber container with your web app
docker tag fabrikamfiber.web:latest "$loginServer/fabrikamfiber.web"

#push it to your registry
docker push "$loginServer/fabrikamfiber.web"
```

It will take a few minutes to push the container to our Azure registry. We are ready to begin setting up our orchestrators in Azure.

# Kubernetes
Azure offers Azure Kubernetes Service, which is a managed Kubernetes solution; the user does not manage the Kubernetes control plane. Instead, the user can focus on just the worker nodes. Azure does not support Windows containers publicly through AKS yet, so we must use acs-engine to deploy our own Kubernetes cluster.

## Configure Tooling

First, we must configure the Azure CLI. Check if you already have a SSH key generated at `~\.ssh\id_rsa.pub`

```PowerShell
dir ~\.ssh\id_rsa.pub
```

If you do not have one, PowerShell will complain that it cannot find it because it does not exist. If it does not exist, then run ssh-keygen.exe. Use the default file, and enter a passphrase if you wish to protect it. Be sure not to use a SSH key with blank passphrase in production. Here is sample output from running this command:

```PowerShell
PS C:\Users\patrick\acs-engine> ssh-keygen.exe
Generating public/private rsa key pair.
Enter file in which to save the key (C:\Users\patrick/.ssh/id_rsa):
Created directory 'C:\Users\patrick/.ssh'.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in C:\Users\patrick/.ssh/id_rsa.
Your public key has been saved in C:\Users\patrick/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:... patrick@plang-g1
The key's randomart image is:
+---[RSA 2048]----+
...
+----[SHA256]-----+
```

### Get ACS-Engine
1. Browse to the ACS-Engine [releases page](https://github.com/Azure/acs-engine/releases) on GitHub.
2. Find the latest version, and download the file ending in `-windows-amd64.zip`.
3. Extract the `acs-engine...-windows-amd64.zip` file to a working folder such as `c:\tools`
4. Check that it runs with `.\acs-engine.exe version`

```none
PS C:\Users\patrick\acs-engine> .\acs-engine.exe version
Version: v0.20.6
GitCommit: 293adfda
GitTreeState: clean
```

5. Add the folder you created in step 3 to your path.

```powershell
$ENV:Path += ';c:\tools'
# If you want to save the setting permanently, then run
$oldPath = [Environment]::GetEnvironmentVariable('Path', [EnvironmentVariableTarget]::User)
[Environment]::SetEnvironmentVariable('Path', $oldPath + ';c:\tools', [EnvironmentVariableTarget]::User)
```

### Get Kubectl

The latest release of Kubernetes Control (kubectl) is available on the [Kubernetes release page](https://kubernetes.io/docs/imported/release/notes/). Look for `kubernetes-client-windows-amd64.tar.gz` and download it.

Windows 10 version 1803 already includes `tar`, so extract the archive and move `kubectl.exe` to the same folder (such as `c:\tools`) that you put `acs-engine.exe`. 

```powershell
tar xvzf C:\Users\patrick\Downloads\kubernetes-client-windows-amd64.tar.gz
Move-Item .\kubernetes\client\bin\kubectl.exe c:\tools
```

## Create a Resource Group and Service Principal

Now that we have the Azure CLI configured and a SSH key generated, it's time to create a resource group to hold the deployment.

ACS-Engine and Kubernetes also need access to deploy resources inside that resource group to build the cluster, as well as configure more resources such as Azure Load Balancers once the cluster is running. This is done using an Azure Service Principal. It's safest to create one with access just to the resource group so that once your deployment is deleted, the service principal can't be used to make other changes in your subscription.

Create a service principal with Contributor access for that group only

```PowerShell
# Get the group id
$groupId = (az group show --resource-group $rgName --query id).Replace("""","")

# Create the service principal
$sp = az ad sp create-for-rbac --role="Contributor" --scopes=$groupId | ConvertFrom-JSON
```

## Create an acs-engine apimodel

We need to create a definition that tells Kubernetes how to run our service. We'll use a basic sample to set up 1 Linux VM to run the Kubernetes service and 2 Windows nodes to run our containers.

```PowerShell
# Be sure to change these next 3 lines for your deployment. Make note that WindowsPassword Windows admin user name cannot be more than 20 characters long, end with a period(.), or contain the following characters: \\ / \" [ ] : | < > + = ; , ? * @.
$dnsPrefix = "fabfiberdemo"
$windowsUser = "fiberuser"
$windowsPassword = "P4ssw0rd!"

# Download template
Invoke-WebRequest -UseBasicParsing https://raw.githubusercontent.com/Azure/acs-engine/master/examples/windows/kubernetes-windows-version.json -OutFile kubernetes-windows.json

# Load template
$inJson = Get-Content .\kubernetes-windows.json | ConvertFrom-Json

# Set dnsPrefix
$inJson.properties.masterProfile.dnsPrefix = $dnsPrefix
$inJson.properties.masterProfile.vmSize = "Standard_D2_v2"

# Set the image type
$inJson.properties.agentPoolProfiles[0].vmSize = "Standard_D2_v2"

# Set Windows username & password
$inJson.properties.windowsProfile.adminPassword = $windowsPassword
$inJson.properties.windowsProfile.adminUsername = $windowsUser
$inJson.properties.windowsProfile.imageVersion = "1709.0.20180717"
$inJson.properties.windowsProfile | add-member -Name "WindowsSku" -value "Datacenter-Core-1709-with-Containers-smalldisk" -MemberType NoteProperty
$inJson.properties.windowsProfile | add-member -Name "WindowsPublisher" -value "MicrosoftWindowsServer" -MemberType NoteProperty
$inJson.properties.windowsProfile | add-member -Name "WindowsOffer" -value "WindowsServerSemiAnnual" -MemberType NoteProperty

# Copy in your SSH public key from `~/.ssh/id_rsa.pub` to linuxProfile.ssh.publicKeys.keyData
$inJson.properties.linuxProfile.ssh.publicKeys[0].keyData = [string](Get-Content "~/.ssh/id_rsa.pub")

# Set servicePrincipalProfile
$inJson.properties.servicePrincipalProfile.clientId = $sp.appId
$inJson.properties.servicePrincipalProfile.secret = $sp.password


# Save file
$inJson | ConvertTo-Json -Depth 5 | Out-File -Encoding ascii -FilePath "kubernetes-windows-complete.json"
```

## Generate Azure Resource Manager template

Now that the ACS-Engine cluster definition is complete, generate the Azure templates. in PowerShell, run:

```PowerShell
acs-engine.exe generate kubernetes-windows-complete.json
```

This will generate a `_output` directory with a subdirectory named after the dnsPrefix you set above.

It will also create a working Kubernetes client config file in `_output/<dnsprefix>/kubeconfig` folder. We'll come back to that in a bit.

## Deploy the cluster

Get the paths to `azuredeploy.json` and `azuredeploy.parameters.json` from the last step, and pass them into `az group deployment create --name <name for deployment> --resource-group <resource group name> --template-file <...azuredeploy.json> --parameters <...azuredeploy.parameters.json>` From PowerShell, run:

```PowerShell
$deploymentName = "fabfiberdeployment"

az group deployment create --name $deploymentName --resource-group $rgName --template-file "./_output/$dnsPrefix/azuredeploy.json" --parameters "./_output/$dnsPrefix/azuredeploy.parameters.json"
```

After several minutes, it will return the list of resources created in JSON. Look for `masterFQDN`.

Next, set an environment variable pointing to your kubernetes config. Make sure to replace `<dnsprefix>` with the appropriate name. From PowerShell:

```PowerShell
$ENV:KUBECONFIG=(Get-Item _output\$dnsPrefix\kubeconfig\kubeconfig.westus2.json).FullName
```

Once you've set that variable, you can verify the cluster is up by running:

```PowerShell
kubectl get node -o wide
```

You should see output similar to below:

```PowerShell
NAME                    STATUS    ROLES     AGE       VERSION   EXTERNAL-IP   OS-IMAGE                    KERNEL-VERSION   CONTAINER-RUNTIME
40336k8s9000            Ready     <none>    21m       v1.9.10   <none>        Windows Server Datacenter   10.0.17134.112
                        docker://17.6.2
40336k8s9001            Ready     <none>    20m       v1.9.10   <none>    Windows Server Datacenter   10.0.17134.112
                        docker://17.6.2
k8s-master-40336153-0   Ready     master    22m       v1.9.10   <none>    Ubuntu 16.04.5 LTS   4.15.0-1018-azure   docker://1.13.1
```

## Deploy the Application

Much like Docker compose, Kubernetes deployments are written in .yaml files. Create the following files:

* `db-deployment.yaml`
* `db-service.yaml`
* `fabrikamfiber.web-deployment.yaml`
* `fabrikamfiber.web-service.yaml`
* `db-secret.yaml`

Let's start with `db-deployment.yaml`. In that file, paste in the following:

```yaml
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  annotations:
    kompose.cmd: kompose convert -f docker-compose-combined.yml
    kompose.version: 1.2.0 (99f88ef)
  creationTimestamp: null
  labels:
    io.kompose.service: db
  name: db
spec:
  replicas: 1
  strategy: {}
  template:
    metadata:
      creationTimestamp: null
      labels:
        io.kompose.service: db
    spec:
      containers:
      - env:
        - name: ACCEPT_EULA
          value: "Y"
        - name: SA_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mssql
              key: SA_PASSWORD
        image: microsoft/mssql-server-windows-developer:1709
        name: db
        ports:
        - containerPort: 1433
        resources: {}
      nodeSelector:
        beta.kubernetes.io/os: windows
      restartPolicy: Always
```

Save and close the file. Next, open `db-service.yaml` and paste in the following:

```yaml
apiVersion: v1
kind: Service
metadata:
  annotations:
    kompose.cmd: kompose convert -f docker-compose-combined.yml
    kompose.version: 1.2.0 (99f88ef)
  creationTimestamp: null
  labels:
    io.kompose.service: db
  name: db
spec:
  ports:
  - name: "1433"
    port: 1433
    targetPort: 1433
  selector:
    io.kompose.service: db
```

Save and close the file. Next, open `fabrikamfiber.web-deployment.yaml` and paste in the following (**NOTE: be sure to replace the container image name below with the appropriate registry name**):

```yaml
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  annotations:
    kompose.cmd: kompose convert -f docker-compose-combined.yml
    kompose.version: 1.2.0 (99f88ef)
  creationTimestamp: null
  labels:
    io.kompose.service: fabrikamfiber.web
  name: fabrikamfiber.web
spec:
  replicas: 1
  strategy: {}
  template:
    metadata:
      creationTimestamp: null
      labels:
        io.kompose.service: fabrikamfiber.web
    spec:
      containers:
      - image: fabfiberregistry.azurecr.io/fabrikamfiber.web:latest
        name: fabrikamfiberweb
        ports:
        - containerPort: 80
        env:
        - name: DB_SA_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mssql
              key: SA_PASSWORD
        resources: {}
        securityContext:
          privileged: true
      restartPolicy: Always
      nodeSelector:
        beta.kubernetes.io/os: windows
status: {}
```

Save and close the file. Next, open `fabrikamfiber.web-service.yaml` and paste in the following:

```yaml
apiVersion: v1
kind: Service
metadata:
  annotations:
    kompose.cmd: kompose convert -f docker-compose-combined.yml
    kompose.version: 1.2.0 (99f88ef)
  creationTimestamp: null
  labels:
    io.kompose.service: fabrikamfiber.web
  name: fabrikamfiberweb
spec:
  ports:
  - name: "80"
    port: 80
    targetPort: 80
  type: "LoadBalancer"
  selector:
    io.kompose.service: fabrikamfiber.web
```

Save and close the file. Next, open `db-secret.yaml` and paste in the following:

```yaml
apiVersion: v1
data:
  SA_PASSWORD: eW91clN0cm9uZyghKVBhc3N3b3Jk
kind: Secret
metadata:
  name: mssql
```

Save the file and close it. From Powershell, invoke kubectl to apply the configuration. kubectl will show the deployment and service were created:

```PowerShell
kubectl create -f db-secret.yaml
kubectl apply -f db-deployment.yaml
kubectl apply -f db-service.yaml
kubectl apply -f fabrikamfiber.web-deployment.yaml
kubectl apply -f fabrikamfiber.web-service.yaml
```

Now, you can check the status of the pod and service with `kubectl get pod` and `kubectl get service` respectively.

Initially, the pod will be in the `ContainerCreating` state, and eventually go to `Running`. The service will show `<pending>` under EXTERNAL-IP. Here's what the first progress will look like:

```PowerShell
PS > kubectl get pod

NAME                                 READY     STATUS              RESTARTS   AGE
db-6f67cf4dcd-252s6                  1/1       Running             0          36m
fabrikamfiber.web-7df6c96d54-fdlkt   0/1       ContainerCreating   0          5m

PS > kubectl get service

NAME               TYPE           CLUSTER-IP     EXTERNAL-IP    PORT(S)        AGE
db                 ClusterIP      10.0.137.163   <none>         1433/TCP       36m
fabrikamfiberweb   LoadBalancer   10.0.24.218    52.183.11.13   80:32442/TCP   36m
kubernetes         ClusterIP      10.0.0.1       <none>         443/TCP        38m
```

Since this is the first deployment, it will probably take several minutes for the Windows node to download and run the container. Later deployments will be faster because the large microsoft/windowsservercore container will already be on disk.

The service will eventually show an EXTERNAL-IP as well:

```PowerShell
kubectl get service
NAME         TYPE           CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE
iis          LoadBalancer   10.0.9.47    13.66.203.178 80:31240/TCP   1m
kubernetes   ClusterIP      10.0.0.1     <none>        443/TCP        46m
```

Once the pod is in Running state, get the IP from kubectl get service then visit http://<EXTERNAL-IP> to test your web server.

Congratulations on deploying a kubernetes cluster via acs-engine in Azure.

# Service Fabric
Azure offers Service Fabric, a distributed systems platform which is capable of orchestrating containers.

## Get the Service Fabric branch

Grab the project if you have not already and checkout the `service_fabric` branch:

```PowerShell
git clone https://github.com/cwilhit/fabrikamfiber.git
git checkout service_fabric
```

## Set up an Azure Container Registry

We set up a container registry earlier in the tutorial. We will be reusing that same container registry. If you have not already set up a container registry, refer to earlier in the tutorial for how to do this.

We do need to change the Service Fabric deployment manifest to the container image that was pushed to your container registry earlier in the tutorial. Open `fabrikamfiber/FabrikamFiber.CallCenterApplication/ApplicationPackageRoot/FabrikamFiber.WebPkg/ServiceManifest.xml`

Look for the line below and change it to your container registry and image:

```Xml
<ServiceManifest>
  ...
  <CodePackage>
    <EntryPoint>
        <ImageName>yourcontainerregistry/yourcontainerimage</ImageName>
    </EntryPoint>
  </CodePackage>
  ...
</ServiceManifest>
```

Next, open `fabrikamfiber/FabrikamFiber.CallCenterApplication/ApplicationPackageRoot/ApplicationManifest.xml` and change the registry credentials to the credentials for *your* registry:

```Xml
<ServiceManifestImport>
  ...
  <Policies>
    <ContainerHostPolicies CodePackageRef="FabrikamFiber.WebPkg" ServiceManifesetVersion="1.0.0">
        <RepositoryCredentials AccountName="yourregistryname" Password="yourregistrypassword" PasswordEncrypted="true"/>
    </EntryPoint>
  </Policies>
  ...
</ServiceManifestImport>
```

## Configure the Service Fabric Cluster

We need to create a definition that tells Service Fabric what SKU VMs we want, where we want them located, etc.

```PowerShell
# Be sure to change these next 3 lines for your deployment. Make note that WindowsPassword Windows admin user name cannot be more than 20 characters long, end with a period(.), or contain the following characters: \\ / \" [ ] : | < > + = ; , ? * @.
$windowsUser = "fiberuser"
$windowsPassword = "P4ssw0rd!"

# Download template
Invoke-WebRequest -UseBasicParsing https://raw.githubusercontent.com/Microsoft/service-fabric-scripts-and-templates/master/templates/cluster-tutorial/vnet-cluster.json -OutFile vnet-cluster.json
Invoke-WebRequest -UseBasicParsing https://raw.githubusercontent.com/Microsoft/service-fabric-scripts-and-templates/master/templates/cluster-tutorial/vnet-cluster.parameters.json -OutFile vnet-cluster.parameters.json

# Load template
$inJson = Get-Content .\vnet-cluster.parameters.json | ConvertFrom-Json

# Set the location
$inJson.parameters.location.value = "westus2"

# Set Windows username & password
$inJson.parameters.adminUserName.value = $windowsUser
$inJson.parameters.adminPassword.value = $windowsPassword

#Set the SKU params
$inJson.parameters.vmImageSku.value = "Datacenter-Core-1709-with-Containers-smalldisk"
$inJson.parameters.vmImageVersion.value = "1709.0.20180717"
$inJson.parameters.vmImageOffer.value = "WindowsServerSemiAnnual"
$inJson.parameters.vmImagePublisher.value = "MicrosoftWindowsServer"

# Save file
$inJson | ConvertTo-Json | Out-File -Encoding ascii -FilePath "vnet-cluster-complete.parameters.json"
```

## Create the cluster

Now we will ask Azure to provision a Service Fabric cluster & associated resources, based upon the configuration files we created above.
 
```PowerShell
$certpwd="q6D7nN%6ck@6" | ConvertTo-SecureString -AsPlainText -Force
$certfolder="c:\mycertificates\"
$clustername = "mysfcluster123"
$vaultname = "fabrikamfibervault"
$vaultgroupname="clusterkeyvaultgroup123"
$subname="$clustername.westus2.cloudapp.azure.com"
$endpoint="$clustername.westus2.cloudapp.azure.com:19000"
$templateFile = (Get-Item .\vnet-cluster.json).FullName
$parameterFile = (Get-Item .\vnet-cluster-complete.parameters.json).FullName

mkdir $certfolder
New-AzureRmServiceFabricCluster -ResourceGroupName $rgName -TemplateFile $templateFile -ParameterFile $parameterFile -CertificatePassword $certpwd -CertificateOutputFolder $certfolder -KeyVaultName $vaultname -KeyVaultResouceGroupName $vaultgroupname -CertificateSubjectName $subname

```

After several minutes, it will return information about the cluster it has just created. Make note of `CertificateSavedLocalPath`

Connect to the cluster using the Service Fabric PowerShell module installed with the Service Fabric SDK. First, install the certificate into the Personal (My) store of the current user on your computer. Run the following PowerShell command:

```PowerShell
$certpwd="q6D7nN%6ck@6" | ConvertTo-SecureString -AsPlainText -Force
#Make sure to change the filepath to what is returned in CertificateSavedLocalPath
Import-PfxCertificate -Exportable -CertStoreLocation Cert:\CurrentUser\TrustedPeople -FilePath C:\mycertificates\crwilhit-sf20180824201615.pfx -Password $certpwd
```

You are now ready to connect to your secure cluster.

Use the Connect-ServiceFabricCluster cmdlet to connect to the secure cluster. **The certificate thumbprint and connection endpoint details are found in the output from the previous step.**

```PowerShell
Connect-ServiceFabricCluster -ConnectionEndpoint $endpoint -KeepAliveIntervalInSec 10 -X509Credential -ServerCertThumbprint 08BFBF7DBBBCBC9A18CE6C445044D5E9E98D41E7 -FindType FindByThumbprint -FindValue 08BFBF7DBBBCBC9A18CE6C445044D5E9E98D41E7 -StoreLocation CurrentUser -StoreName My

#Check to make sure you are connected by verifying the health of the cluster.
Get-ServiceFabricClusterHealth
```

You should see output similar to below:

```PowerShell
AggregatedHealthState   : Ok
NodeHealthStates        : None
ApplicationHealthStates : None
HealthEvents            : None
HealthStatistics        :
                          Node                  : 0 Ok, 0 Warning, 0 Error
                          Application           : 0 Ok, 0 Warning, 0 Error
                          Service               : 0 Ok, 0 Warning, 0 Error
                          Partition             : 0 Ok, 0 Warning, 0 Error
                          Replica               : 0 Ok, 0 Warning, 0 Error
                          DeployedApplication   : 0 Ok, 0 Warning, 0 Error
                          DeployedServicePackage : 0 Ok, 0 Warning, 0 Error
```

## Deploy the Application

You need to build a release version of the project. Change directories to your project's `FabrikamFiber/FabrikamFiber.CallCenterApplication/Scripts` folder. Use the deploy script to deploy to the cluster. *Note: make sure to run this after running the above Connect-ServiceFabricCluster command--it will reuse the connection*.

```PowerShell
.\Deploy-FabricApplication.ps1 -UseExistingClusterConnection -PublishProfileFile "..\PublishProfiles\Cloud.xml" -ApplicationPackagePath "../pkg/Release"
```

Now, you can check the status of the cluster by running `Get-ServiceFabricClusterhealth`. It will take several mintues for the cluster to reach a healthy state. Service Fabric will report an error while the container images are pulled and then eventually run.

Once the pod is in Running state, visit http://"$clustername.westus2.cloudapp.azure.com" to be greeted by the fabrikam fiber application.

Congratulations on deploying a Service Fabric cluster into Azure.
